<!doctype html> <!-- Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes Free for personal and commercial use under the MIT license https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE --><html lang="en" class="no-js"><head><meta charset="utf-8"> <!-- begin _includes/seo.html --><title>Variance Distilled - Glob Attack</title><meta name="description" content="Variance Distilled"><meta name="author" content="Samuel SAYAG"><meta property="article:author" content="Samuel SAYAG"><meta property="og:type" content="article"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="Glob Attack"><meta property="og:title" content="Variance Distilled"><meta property="og:url" content="htps://samuelsayag.github.io/scala/variance/variance-distilled"><meta property="og:description" content="Variance Distilled"><meta property="og:image" content="htps://samuelsayag.github.io/assets/images/scala-variance.jpg"><meta property="article:published_time" content="2021-07-21T00:00:00+03:00"><link rel="canonical" href="htps://samuelsayag.github.io/scala/variance/variance-distilled"> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "Person", "name": "Samuel SAYAG", "url": "htps://samuelsayag.github.io/" } </script> <!-- end _includes/seo.html --><link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Glob Attack Feed"> <!-- https://t.co/dKP3o1e --><meta name="viewport" content="width=device-width, initial-scale=1.0"> <script> document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js '; </script> <!-- For all browsers --><link rel="stylesheet" href="/assets/css/main.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript> <!-- start custom head snippets --> <!-- insert favicons. use https://realfavicongenerator.net/ --> <!-- end custom head snippets --></head><body class="layout--single"><nav class="skip-links"><ul><li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li><li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li><li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li></ul></nav><!--[if lt IE 9]><div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]--><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"> <a class="site-title" href="/"> <span class="site-subtitle">Sam's Blog</span> </a><ul class="visible-links"></ul><button class="greedy-nav__toggle hidden" type="button"> <span class="visually-hidden">Toggle menu</span><div class="navicon"></div></button><ul class="hidden-links hidden"></ul></nav></div></div></div><div class="initial-content"><div class="page__hero--overlay" style=" background-image: url('/assets/images/scala-variance.jpg');" ><div class="wrapper"><h1 id="page-title" class="page__title" itemprop="headline"> Variance Distilled</h1><p class="page__lead">Variance Distilled</p><p class="page__meta"> <span class="page__meta-date"> <i class="far fa-calendar-alt" aria-hidden="true"></i> <time datetime="2021-07-21T00:00:00+03:00">July 21, 2021</time> </span> <span class="page__meta-sep"></span> <span class="page__meta-readtime"> <i class="far fa-clock" aria-hidden="true"></i> 15 minute read </span></p></div></div><div id="main" role="main"><div class="sidebar sticky"><div itemscope itemtype="https://schema.org/Person"><div class="author__avatar"> <img src="/assets/images/carte.jpg" alt="Samuel SAYAG" itemprop="image"></div><div class="author__content"><h3 class="author__name" itemprop="name">Samuel SAYAG</h3><div class="author__bio" itemprop="description"><p>I am a father, software engineer, pyout listener…and much more.</p></div></div><div class="author__urls-wrapper"> <button class="btn btn--inverse">Follow</button><ul class="author__urls social-icons"><li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place"> <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Jerusalem, Israel</span></li><li> <a href="mailto:globattack@gmail.com"><meta itemprop="email" content="globattack@gmail.com" /> <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span> </a></li><!--<li> <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer"> <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link </a></li>--></ul></div></div></div><article class="page" itemscope itemtype="https://schema.org/CreativeWork"><meta itemprop="headline" content="Variance Distilled"><meta itemprop="description" content="Variance Distilled"><meta itemprop="datePublished" content="2021-07-21T00:00:00+03:00"><div class="page__inner-wrap"><section class="page__content" itemprop="text"><aside class="sidebar__right "><nav class="toc"><header><h4 class="nav__title"><i class="fas fa-cog"></i> Table of Contents</h4></header><ul class="toc__menu"><li><a href="#scala-variance-distilled">Scala Variance Distilled</a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#some-other-good-resource-that-you-would-want-to-try">Some other good resource that you would want to try…</a></li><li><a href="#organisation">Organisation</a></li><li><a href="#what-is-variance">What is variance?</a></li><li><a href="#how-do-we-enforce-variance">How do we enforce variance?</a></li><li><a href="#but-why-variance-after-all">But why variance after all?</a></li><li><a href="#what-do-we-owe-to-the-scala-compiler">What do we owe to the Scala compiler?</a><ul><li><a href="#the-producerconsumer-mental-model">The Producer/Consumer mental model</a><ul><li><a href="#receiving-some-t-from-the-container">Receiving some T from the Container</a></li><li><a href="#passing-some-t-to-the-container">Passing some T to the Container</a></li></ul></li><li><a href="#compilation-problems-relative-to-covariantcontravariant-position">Compilation problems relative to covariant/contravariant position</a><ul><li><a href="#problem-with-covariant-container">Problem with Covariant container</a></li></ul></li><li><a href="#problems-with-contravariant-container">Problems with Contravariant container</a></li></ul></li><li><a href="#the-example-of-zio">The example of ZIO</a></li><li><a href="#conclusion">Conclusion</a></li></ul></li></ul></nav></aside><h1 id="scala-variance-distilled">Scala Variance Distilled</h1><h2 id="introduction">Introduction</h2><p>This article could have been called YAASV (“Yet Another Article on Scala Variance”).</p><p>There is already a lot of (good!) resources about variance out there (more about that in the next section). So why making another article about it?</p><p>Well, because if reading these resources gives actually a good grasp on the basics such as the definition, the technical aspect of it, the mental model (producer/consumer) that one has to build in order to understand it better, I always finished my reading without feeling that I could practically use this knowledge. It was still a bit abstract, the kind of academic one that is useful to understand type signature but was not really part of my realm, my toolbox.</p><p>The picture changed recently when I received some really pertinent explanation thanks to a workshop on Functional Data Modelling given by <a href="https://degoes.net/" title="John de Goes's Blog">John de Goes</a>. I got some answer about apparently very basic questions: Why is variance implanted in the Scala language? What does it bring to the table? Should it be use with parsimony or wherever possible? How does the (type inference) world look without it? …and so on.</p><p>By the end, the picture seemed kind of clear so I decided that I should write something about it in order to prove to myself that I actually really understood it. But I wanted to cover some gaps I could see in other resources so that it eventually can be a practical thing for others.</p><h2 id="some-other-good-resource-that-you-would-want-to-try">Some other good resource that you would want to try…</h2><p>If your patient enough to read whole chapters of books you may want to give a try to these excellent ones:</p><ul><li><a href="https://learning.oreilly.com/library/view/programming-scala-3rd/9781492077886/" title="Dean Wampler, Programming Scala 3rd (or 2nd) Ed., Chap. 11">Martin Odersky, Lex Spoon, and Bill Venners, “Programming in Scala, 4th Ed. (or 2nd or 3rd) Ed., Chap 19”</a></li><li><a href="https://www.artima.com/shop/programming_in_scala_4ed" title="Programming in Scala, 4th Ed. (or 2nd or 3rd) Ed., Chap 19">“Dean Wampler, Programming Scala 3rd (or 2nd) Ed., Chap. 11”</a></li></ul><p>If you just want to read a few introductions on it you certainly would enjoys these also:</p><ul><li><a href="https://apiumhub.com/tech-blog-barcelona/scala-generics-covariance-contravariance/" title="Scala Generics II, Variance">Scala Generics II</a></li><li><a href="https://blog.knoldus.com/covariance-and-contravariance-in-scala/" title="Covariance &amp; Contravariance in Scala">Covariance &amp; Contravariance in Scala</a></li><li><a href="https://dev.to/vitornovictor/contravariance-in-the-real-world-29l" title="Contravariance in the real World">Contravariance in the Real World</a></li><li><a href="https://lansalo.com/2017/10/22/scala-variance-explained/" title="Scala Variance explained">Scala Variance explained</a></li></ul><p>…or read what follows of course.</p><h2 id="organisation">Organisation</h2><p>I think that a practical understanding of variance have to include an answer to the following questions:</p><ul><li><strong>What</strong> is it? <em>Meaning</em>: What is the definition and can we dissect every <em>hard</em> concept of it so that every part is clear?</li><li><strong>How</strong> is it implemented in Scala? <em>Meaning</em>: how does it appear in Scala code or how to use it?</li><li><strong>Why</strong> is there variance? <em>Meaning</em>: what does it brings to the table for us? (and how much does we have to pay for it in terms of constraint?)</li></ul><h2 id="what-is-variance">What is variance?</h2><blockquote><p>Variance is given to parameter(s) of type constructors. It is an assertion made to the Scala compiler that, given an existing subtyping relationship between concrete types, <em>we want it to enforce</em> a subtyping relationship between type constructors that were built with these types.</p></blockquote><p>Yeah, I know. A mouthful. But, actually, every bits of this definition is important. So let’s break it.</p><p>First of all we need a <em>subtyping relationship between concrete types</em>. What is it? This:</p><p><a name="concrete_type_hierarchy"> A concrete type hierarchy:</a></p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// I have this hierarchy of types</span>
<span class="c1">//             A</span>
<span class="c1">//            ↗ ↖</span>
<span class="c1">//           B   C</span>

<span class="k">trait</span> <span class="nc">A</span>
<span class="k">trait</span> <span class="nc">B</span> <span class="k">extends</span> <span class="n">A</span> 
<span class="k">trait</span> <span class="nc">C</span> <span class="k">extends</span> <span class="n">A</span> 

<span class="c1">// what is (one of) the power behind it? This!</span>
<span class="c1">// A is an A, B is an A and, C is an A</span>
<span class="k">val</span> <span class="nv">a1</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">{}</span>
<span class="k">val</span> <span class="nv">a2</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="o">{}</span>
<span class="k">val</span> <span class="nv">a3</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="o">{}</span>

</code></pre></div></div><p><strong>During the article I will refer to this hierarchy again and again without always display it again</strong></p><p>On the other side we have <em>type constructors</em>.</p><p>They are also types but not concrete ones (they are called <em>higher kinded types</em>).</p><p>As their name (<em>type constructors</em>) suggest, a concrete type can be built from them. In practice, you feed a type constructor one (or more..) concrete types and you receive a concrete type.</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// this is a type constructor</span>
<span class="c1">// by the way T is called a "type parameter" and you can have many of them.</span>
<span class="c1">// Container[T] can also be called a "parametric type" because...it has a type parameter :)</span>
<span class="c1">// Because parametriciy is also called genericity in Java, they are also call generic types.</span>
<span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> 

<span class="c1">// or other more commons</span>
<span class="c1">// I omitter the variance because I still haven't introduced it!</span>
<span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">trait</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
<span class="k">trait</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">trait</span> <span class="nc">ZIO</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span>

<span class="c1">// building a concrete type out of it</span>
<span class="k">type</span> <span class="kt">ContainerOfInt</span> <span class="o">=</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="c1">// buiding a value....</span>
<span class="k">val</span> <span class="nv">c1</span><span class="k">:</span> <span class="kt">ContainerOfInt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">Int</span><span class="o">]{}</span>
</code></pre></div></div><p>If you want a nice and deep intuition you can put it like that: <em>type constructors</em> are equivalent to functions operating at type level. If a function is “give me one (or more) value I will return you another one” (value level), the type constructor is “give me one (or more) types I will return you a concrete one” (type level).</p><p>Now, what is crucial to understand is that we get to fix the variance of a type constructor. We decide in a complete <em>arbitrary fashion</em> what will be the subtyping relationship of a given type constructor (<code class="language-plaintext highlighter-rouge">Container[T]</code>) that wraps a concrete hierarchy of types.</p><p>Again: YOU have to decide. Of course, it is usually backed by serious design arguments (more later about it), but it stays that it is an arbitrary decision i.e an “assertion you make to the compiler”.</p><p>Of course, once the type is set on a specific variance, the compiler will enforce some rules that will constraint our type contructors (its methods…) but also gives us more power in certain case.</p><p>But how do we actually enforce variance…</p><h2 id="how-do-we-enforce-variance">How do we enforce variance?</h2><p>There are three type of variance that can be enforce in Scala, provided <a href="#concrete_type_hierarchy">this hierarchy</a>:</p><p>Reminder of the above concrete type hierary:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// I have this hierarchy of types</span>
<span class="c1">//             A</span>
<span class="c1">//            ↗ ↖</span>
<span class="c1">//           B   C</span>
</code></pre></div></div><table><thead><tr><th><b>Variance</b></th><th><b>Declaration</b></th><th><b>Type constructor subtyping relationship</b></th></tr></thead><tbody><tr><td><i>Covariance</i></td><td><code>Container[+T]</code></td><td><pre>
// I have this resulting hierarchy of type constructor
//             Container[A]  Container[A]         
//                 🠑             🠑    
//             Container[B]  Container[C] 
			 </pre></td></tr><tr><td><i>Invariance</i></td><td><code>Container[T]</code></td><td><pre>
// Container[A], Container[B] and Container[C]
// are completely unrelated types from the compiler 
// point of view.
			 </pre></td></tr><tr><td><i>Contravariance</i></td><td><code>Container[-T]</code></td><td><pre>
// I have this resulting hierarchy of type constructor
//             Container[B]  Container[C]         
//                 🠑             🠑    
//             Container[A]  Container[A] 
			 </pre></td></tr></tbody></table><p>Some important remarks:</p><ul><li>Variance can be applied <em>only</em> on immutable types.</li><li>Variance is set <em>only</em> at declaration of type constructors in Scala (it is called <em>declaration site variance</em>).</li><li>A single container may have multiple parameter types having different variance e.g <code class="language-plaintext highlighter-rouge">ZIO[-R, +E, +A]</code> We say that <code class="language-plaintext highlighter-rouge">ZIO</code> is contravariant in <code class="language-plaintext highlighter-rouge">R</code> and covariant in <code class="language-plaintext highlighter-rouge">E</code> and <code class="language-plaintext highlighter-rouge">A</code>…and invariant in Nothing :)</li></ul><p>All this is really nice, but what the heck is it good for? Is there some implications on compilation, some contraints on types? How are designed types with respect to variance?</p><h2 id="but-why-variance-after-all">But why variance after all?</h2><p>We said it, enforcing variance is arbitrary. In other word, you get to decide the <code class="language-plaintext highlighter-rouge">[+, (nothing here), -]</code> that is going to adorn you type constructor’s type parameters.</p><p>Once you commit to a specific variance for a specific type parameter you make a trade with the Scala compiler:</p><ul><li>You pay: “severe” restriction on the way you code your method on the <code class="language-plaintext highlighter-rouge">Container[T]</code> (more on this later).</li><li>You have: the <em>is a</em> relationship of your container wrapping types is real and this allows to code methods for a variety of types one time because it will be availale to all the subtype.</li><li>You have: crazy good type inference!</li></ul><p>Let’s explain the second point.</p><p>By applying variance, you get a parameter passing experience that relates “correcly” to the intuitiion, the feeling that it <em>should</em> work!</p><p>For instance, given <a href="#concrete_type_hierarchy">our above <code class="language-plaintext highlighter-rouge">A/B/C</code> hierarchy</a> and <code class="language-plaintext highlighter-rouge">List[+A]</code> being covariant it is natural to think that if a method take a <code class="language-plaintext highlighter-rouge">List[A]</code>, it should also accept a <code class="language-plaintext highlighter-rouge">List[B]</code> or a <code class="language-plaintext highlighter-rouge">List[C]</code></p><p>Why? This is interesting actually. In our mind, we know that the way to use a <code class="language-plaintext highlighter-rouge">List</code> is actually to get some elements out of it (i.e <code class="language-plaintext highlighter-rouge">List</code> <em>produces</em> elements for us) so we guess that any subtype of the list type should work because a subtype just increase the power (i.e have more methods, more fields for instance) of its supertype and therefore can be used in place of the supertype (this is called the Liskov Substitution Principle).</p><p>But hey, this is cool! I know that wherever I need an <code class="language-plaintext highlighter-rouge">A</code> I can actually provide a <code class="language-plaintext highlighter-rouge">B</code> or a <code class="language-plaintext highlighter-rouge">C</code> and the above section showed me that a <code class="language-plaintext highlighter-rouge">List[A]</code> could be replaced by a <code class="language-plaintext highlighter-rouge">List[B]</code> or a <code class="language-plaintext highlighter-rouge">List[C]</code>! So it goes in the same direction no? Could we consider a <code class="language-plaintext highlighter-rouge">List[B]</code> a subtype of <code class="language-plaintext highlighter-rouge">List[A]</code>? Totally! This is called <em>covariance</em>!</p><p>With our <code class="language-plaintext highlighter-rouge">Container[_]</code> type:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// suppose Container has been declared invariant</span>
<span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

<span class="c1">// A, B and C are concrete type according to the above hierarchy</span>
<span class="k">val</span> <span class="nv">c1</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">val</span> <span class="nv">c2</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">val</span> <span class="nv">c3</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> 

<span class="c1">// a method taking a Container of the concrete type A</span>
<span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span>

<span class="c1">// if Container is invariant in A like the declaration above </span>
<span class="nf">foo</span><span class="o">(</span><span class="n">c1</span><span class="o">)</span> <span class="c1">// this compile</span>
<span class="nf">foo</span><span class="o">(</span><span class="n">c2</span><span class="o">)</span> <span class="c1">// this DOES NOT compile</span>
<span class="nf">foo</span><span class="o">(</span><span class="n">c3</span><span class="o">)</span> <span class="c1">// this DOES NOT compile</span>

<span class="c1">// now suppose Container has been declared covariant</span>
<span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span>
<span class="nc">foo</span><span class="o">(</span><span class="n">c1</span><span class="o">)</span> <span class="c1">// this compile</span>
<span class="nf">foo</span><span class="o">(</span><span class="n">c2</span><span class="o">)</span> <span class="c1">// this compile</span>
<span class="nf">foo</span><span class="o">(</span><span class="n">c3</span><span class="o">)</span> <span class="c1">// this compile</span>

</code></pre></div></div><p>Some important take away:</p><ul><li>We can code for multiple type in a secure (compiler controller) fashion with variance.</li><li><em>better type inference</em> is not a caprice but actually a pretty handy feature!</li></ul><h2 id="what-do-we-owe-to-the-scala-compiler">What do we owe to the Scala compiler?</h2><p>Now, we have understood the “What” and the “How” of variance and even a good bit of the “Why” (we got an intuition about why a type could be logically covariant).</p><p>Still two important questions are pending:</p><ul><li>When a type constructor is designed (such as <code class="language-plaintext highlighter-rouge">Array[T]</code>, <code class="language-plaintext highlighter-rouge">Option[+A]</code>, <code class="language-plaintext highlighter-rouge">Function1[-T1, +R]</code>, <code class="language-plaintext highlighter-rouge">List[+A]</code>, <code class="language-plaintext highlighter-rouge">ZIO[-R,+E,+A]</code>…), i.e how does the variance is decided for its type parameters?</li><li>While coding the method of the container we may trigger “strange” errors from the compiler telling us that a given type parameters occurs in “covariant” or “contravariant” position.</li></ul><p>What does it mean? What can we do about it?</p><h3 id="the-producerconsumer-mental-model">The Producer/Consumer mental model</h3><p>This part will attempt to explain the first of the above points.</p><p>Suppose we think about a data type i.e a new <code class="language-plaintext highlighter-rouge">Container[T]</code> (immutable with a single type parameter) that is going to have some interesting properties.</p><p>Now, we are asking ourselves: Is <code class="language-plaintext highlighter-rouge">Container</code> invariant, covariant or contravariant in <code class="language-plaintext highlighter-rouge">T</code>?</p><p>To answer this question we have to imagine our data type in action. So let’s suppose we have a function that take it as a parameter and will do something interesting with it:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">doStuffWithContainer</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> 
<span class="c1">// or it could be</span>
<span class="k">def</span> <span class="nf">doStuffWithContainer</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> 
<span class="c1">// or also</span>
<span class="k">def</span> <span class="nf">doStuffWithContainer</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> 
</code></pre></div></div><p>Note: this is not really a function but a parametric function (“a function constructor”) whose type has to be fixed at compile time but we want to make it simple here so we’ll call it a function!</p><p>The implementation of <code class="language-plaintext highlighter-rouge">doStuffWithContainer</code> is going to interact with the container in ways that we could sum-up:</p><ul><li>Receiving some <code class="language-plaintext highlighter-rouge">T</code> from it</li><li>Passing some <code class="language-plaintext highlighter-rouge">T</code> to it</li><li>Do both</li></ul><p>Other possibilities:</p><ul><li>Do nothing with it but, but that is not very intersting nor it is well designed…</li><li>Do something with the container that does not involve any <code class="language-plaintext highlighter-rouge">T</code>. This is actually interesting as it paves the way to some explanation about <em>path dependent type</em> but let put it aside because it is not the subject.</li></ul><p>Let’s see what happen with the above hypothese.</p><h4 id="receiving-some-t-from-the-container">Receiving some <code class="language-plaintext highlighter-rouge">T</code> from the <code class="language-plaintext highlighter-rouge">Container</code></h4><p>This means that once we fix the type <code class="language-plaintext highlighter-rouge">T</code> (let’s say for the concrete type A <code class="language-plaintext highlighter-rouge">doStuffWithContainer[A]</code>) any instance of a subtype of <code class="language-plaintext highlighter-rouge">A</code> could also be received without problem by the implementation of the function. This means in particular that: <code class="language-plaintext highlighter-rouge">B</code> and <code class="language-plaintext highlighter-rouge">C</code> would also work. In other words if:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// I have this hierarchy of types</span>
<span class="c1">//             A</span>
<span class="c1">//            ↗ ↖</span>
<span class="c1">//           B   C</span>
</code></pre></div></div><p>and…</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">doStuffWithContainer</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">A</span><span class="o">]{})</span> <span class="c1">// work</span>
<span class="n">doStuffWithContainer</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">B</span><span class="o">]{})</span> <span class="c1">// would work also ideally!</span>
<span class="n">doStuffWithContainer</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">C</span><span class="o">]{})</span> <span class="c1">// would work also ideally!</span>
</code></pre></div></div><p>If <code class="language-plaintext highlighter-rouge">Container[T]</code> is invariant in <code class="language-plaintext highlighter-rouge">T</code>, <code class="language-plaintext highlighter-rouge">Container[A]</code>, <code class="language-plaintext highlighter-rouge">Container[B]</code> and <code class="language-plaintext highlighter-rouge">Container[C]</code> will be completely unrelated types from the compiler point of view (so the last 2 line of the above code will not work!).</p><p>But if <code class="language-plaintext highlighter-rouge">Container[+T]</code> is covariant in <code class="language-plaintext highlighter-rouge">T</code> it will work without problem.</p><p>To sum-up:</p><blockquote><p>If our function implementation is receiving some values of type <code class="language-plaintext highlighter-rouge">T</code> out of the container, covariance seems the way to go in order to accept not just <code class="language-plaintext highlighter-rouge">Container[T]</code> but <code class="language-plaintext highlighter-rouge">Container</code> of all it subtype also! In other word, when we need the type to be a <em>Producer</em> of values we make it <em>Contravariant</em>.</p></blockquote><h4 id="passing-some-t-to-the-container">Passing some <code class="language-plaintext highlighter-rouge">T</code> to the <code class="language-plaintext highlighter-rouge">Container</code></h4><p>This means that if we fix the type of the method to the concrete type, say <code class="language-plaintext highlighter-rouge">B</code>, it will internally pass some <code class="language-plaintext highlighter-rouge">B</code> to the <code class="language-plaintext highlighter-rouge">Container</code>. If the <code class="language-plaintext highlighter-rouge">Container</code> is asking for <code class="language-plaintext highlighter-rouge">B</code>s or any supertype of <code class="language-plaintext highlighter-rouge">B</code>, the function will perform correctly. In particular: <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">Any</code> would work. So, if:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// I have this hierarchy of types</span>
<span class="c1">//            Any </span>
<span class="c1">//             🠕</span>
<span class="c1">//             A</span>
<span class="c1">//            ↗ ↖</span>
<span class="c1">//           B   C</span>
</code></pre></div></div><p>and…</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">???</span>
<span class="n">doStuffWithContainer</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">B</span><span class="o">]{})</span> <span class="c1">// work</span>
<span class="n">doStuffWithContainer</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">A</span><span class="o">]{})</span> <span class="c1">// would work also ideally!</span>
<span class="n">doStuffWithContainer</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">Any</span><span class="o">]{})</span> <span class="c1">// would work also ideally!</span>
</code></pre></div></div><p>If <code class="language-plaintext highlighter-rouge">Container[T]</code> is invariant in <code class="language-plaintext highlighter-rouge">T</code>, <code class="language-plaintext highlighter-rouge">Container[A]</code>, <code class="language-plaintext highlighter-rouge">Container[B]</code> and <code class="language-plaintext highlighter-rouge">Container[Any]</code> will be completely unrelated types from the compiler point of view (so the last 2 line of the above code will not work!).</p><p>But if <code class="language-plaintext highlighter-rouge">Container[-T]</code> is contravariant in <code class="language-plaintext highlighter-rouge">T</code> it will work without problem.</p><p>To sum-up:</p><blockquote><p>If our function implementation is passing some values of type <code class="language-plaintext highlighter-rouge">T</code> to the container, contravariance seems the way to go in order to accept not just <code class="language-plaintext highlighter-rouge">Container[T]</code> but <code class="language-plaintext highlighter-rouge">Container</code> of its supertypes also! In other word, when we need the type to be a <em>Producer</em> of values we make it <em>Contravariant</em>.</p></blockquote><h3 id="compilation-problems-relative-to-covariantcontravariant-position">Compilation problems relative to covariant/contravariant position</h3><h4 id="problem-with-covariant-container">Problem with Covariant container</h4><p>Suppose the following code:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">A</span>
<span class="k">trait</span> <span class="nc">B</span> <span class="k">extends</span> <span class="n">A</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">}</span>
<span class="k">trait</span> <span class="nc">C</span> <span class="k">extends</span> <span class="n">A</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">bar</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">CovContainer</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">insider</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="nf">doStuff</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="c1">// this cannot compile!</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">CovContainer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">make</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">CovContainer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">CovContainer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">insider</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">i</span>
      <span class="k">def</span> <span class="nf">doStuff</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">i</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Here we are trying to create a <em>Producer</em> type so we make it covariant according to what we discovered.</p><p>The <code class="language-plaintext highlighter-rouge">doStuff(t: T): T</code> function does not compile and we receive this message from the compiler:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">E</span><span class="o">]</span>  <span class="n">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span> <span class="kt">contravariant</span> <span class="kt">position</span> <span class="kt">in</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">t</span>
<span class="o">[</span><span class="kt">E</span><span class="o">]</span>  <span class="n">L21</span><span class="k">:</span>     <span class="kt">def</span> <span class="kt">doStuff</span><span class="o">(</span><span class="kt">t:</span> <span class="kt">T</span><span class="o">)</span><span class="kt">:</span> <span class="kt">T</span>
<span class="o">[</span><span class="kt">E</span><span class="o">]</span>                       <span class="o">^^^^</span>
</code></pre></div></div><p>The compiler is trying to tell us that our code is not sound for the moment i.e it could lead to some contradictions. If we accept that our code are actually logical assertion, the compiler says that, had it compile the method reveiving <code class="language-plaintext highlighter-rouge">t:T</code> in parameter, we could create un-sound assertion. And indeed we could:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">cci</span><span class="k">:</span> <span class="kt">CovContainer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">CovContainer</span><span class="o">.</span><span class="py">make</span><span class="o">(</span><span class="mi">555</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">cci</span><span class="o">.</span><span class="py">insider</span><span class="o">)</span> <span class="c1">// would have return 555</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">cci</span><span class="o">.</span><span class="py">doStuff</span><span class="o">(</span><span class="mi">111</span><span class="o">))</span> <span class="c1">// would have return 666</span>

<span class="c1">// let see what kind of contradiction we can tell the compiler to create</span>
<span class="c1">// this work because the Container is declared contravariant</span>
<span class="k">val</span> <span class="nv">cca</span><span class="k">:</span> <span class="kt">CovContainer</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">cci</span>
<span class="c1">// BOOOOM!!!! This will try to add Int to String</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">cca</span><span class="o">.</span><span class="py">doStuff</span><span class="o">(</span><span class="s">"Hi, I am sam"</span><span class="o">))</span>
</code></pre></div></div><p>We can fix the method this way:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">doStuff</span><span class="o">[</span><span class="kt">T1</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T1</span><span class="o">)</span><span class="k">:</span> <span class="kt">T1</span>
</code></pre></div></div><p>This mean that if we are willing to pass a paramter (i.e be a <em>Consumer</em> type) then the implementation need to be valid for any type <code class="language-plaintext highlighter-rouge">T1</code> that can be <code class="language-plaintext highlighter-rouge">Int</code> but also any other concrete supertype of it. This drastically reduce the possible implementations but at the same time it reveal the high price (with respect to soundness) of being both covariant with a contravariant method.</p><h3 id="problems-with-contravariant-container">Problems with Contravariant container</h3><p>In the same fashion on this code as a base:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">trait</span> <span class="nc">A</span>
  <span class="k">trait</span> <span class="nc">B</span> <span class="k">extends</span> <span class="n">A</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">foo</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">}</span>
  <span class="k">trait</span> <span class="nc">D</span> <span class="k">extends</span> <span class="n">B</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">bar</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">}</span>

  <span class="k">trait</span> <span class="nc">ContraContainer</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">passMe</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
    <span class="k">def</span> <span class="nf">doStuff</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
  <span class="o">}</span>

  <span class="k">object</span> <span class="nc">ContraContainer</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">make</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">ContraContainer</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">ContraContainer</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">private</span> <span class="k">var</span> <span class="n">bb</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">def</span> <span class="nf">passMe</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">println</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
        <span class="k">def</span> <span class="nf">doStuff</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">bb</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div><p>We have this type of error on <code class="language-plaintext highlighter-rouge">def doStuff(t: T): T</code>:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="n">contravariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span> <span class="kt">covariant</span> <span class="kt">position</span> <span class="kt">in</span> <span class="k">type</span> <span class="o">(</span><span class="kt">t:</span> <span class="kt">T</span><span class="o">)</span><span class="kt">T</span> <span class="kt">of</span> <span class="kt">method</span> <span class="kt">doStuff</span>
<span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="n">L54</span><span class="k">:</span>     <span class="kt">def</span> <span class="kt">doStuff</span><span class="o">(</span><span class="kt">t:</span> <span class="kt">T</span><span class="o">)</span><span class="kt">:</span> <span class="kt">T</span>
<span class="o">[</span><span class="kt">E</span><span class="o">]</span>                       <span class="o">^^^^</span>
</code></pre></div></div><p>And would it compile, we could create an unsound code that lead to a contradiction:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="nv">cvc1</span> <span class="k">=</span> <span class="nv">ContraContainer</span><span class="o">.</span><span class="py">make</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span> <span class="o">{})</span>
  <span class="nv">cvc1</span><span class="o">.</span><span class="py">passMe</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span> <span class="o">{})</span>
  <span class="nv">cvc1</span><span class="o">.</span><span class="py">doStuff</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span> <span class="o">{})</span>

  <span class="c1">// this is possible because ContraContainer is contravariant</span>
  <span class="k">val</span> <span class="nv">cvc2</span><span class="k">:</span> <span class="kt">ContraContainer</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">cvc1</span>
  <span class="c1">// booooom! This call bar() on the runtime B type that does not have it</span>
  <span class="nv">cvc2</span><span class="o">.</span><span class="py">doStuff</span><span class="o">(</span><span class="k">new</span> <span class="n">D</span> <span class="o">{}).</span><span class="py">bar</span><span class="o">()</span>
</code></pre></div></div><p>The method <code class="language-plaintext highlighter-rouge">doStuff</code> has to be corrected as follows:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">doStuff</span><span class="o">[</span><span class="kt">T1</span> <span class="k">&lt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T1</span><span class="o">)</span><span class="k">:</span> <span class="kt">T1</span>
</code></pre></div></div><h2 id="the-example-of-zio">The example of <code class="language-plaintext highlighter-rouge">ZIO</code></h2><p>The <a href="https://zio.dev/" title="ZIO Dev">ZIO library</a> provide numerous good example of the way to deal with variance (both co- and contra-).</p><p>The <code class="language-plaintext highlighter-rouge">ZIO</code> type as the following simplified signature:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ZIO</span><span class="o">[</span><span class="kt">-R</span>, <span class="kt">+E</span>, <span class="kt">+A</span><span class="o">]</span>
</code></pre></div></div><p>It is contravariant in <code class="language-plaintext highlighter-rouge">R</code> (the environment) and covariant in <code class="language-plaintext highlighter-rouge">E</code> the error type and <code class="language-plaintext highlighter-rouge">A</code> the success type.</p><p>In the light of what has been studied here, it can be understood as:</p><ul><li>A consumer type of an environment (<code class="language-plaintext highlighter-rouge">R</code>)</li><li>A producer type of either an error <code class="language-plaintext highlighter-rouge">E</code> either a succcess value <code class="language-plaintext highlighter-rouge">A</code></li></ul><p>Let’s take a method so see how the contravariant/covariant position error are avoided:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Returns an effect that executes both this effect and the specified effect, in parallel, returning result of provided effect.
 */</span>
<span class="o">&amp;&gt;[</span><span class="kt">R1</span> <span class="k">&lt;:</span> <span class="kt">R</span>, <span class="kt">E1</span> <span class="k">&gt;:</span> <span class="kt">E</span>, <span class="kt">B</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">ZIO</span><span class="o">[</span><span class="kt">R1</span>, <span class="kt">E1</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ZIO</span><span class="o">[</span><span class="kt">R1</span>, <span class="kt">E1</span>, <span class="kt">B</span><span class="o">]</span>
</code></pre></div></div><p>Reading this <code class="language-plaintext highlighter-rouge">[R1 &lt;: R, E1 &gt;: E, B]</code> we can now understand that:</p><ul><li>producing a ZIO value with a contravariant type, we need <code class="language-plaintext highlighter-rouge">R1 &lt;: R</code> to satisfy the compiler.</li><li>consuming a ZIO value with an covariant type, we need <code class="language-plaintext highlighter-rouge">E1 &gt;: E</code> to satify the compiler.</li><li>the purpose of the method being to return the <code class="language-plaintext highlighter-rouge">that</code> effect we just need to return <code class="language-plaintext highlighter-rouge">B</code> here.</li></ul><h2 id="conclusion">Conclusion</h2><ul><li>Variance is a subtyping relationship between type constructors given a subtyping relationship between concrete types</li><li>The subtyping relationship can follow the underlying types relationship (covariance), invert it (contravariance) or forget the underlying relationship (invariance).</li><li>Applying variance to a type parameter when declaring a type constructor is the responsibility of the creator of the type.</li><li>The variance can be decided according to the role (Producer/Consumer/Both) of the type parameter in the type constructor</li><li>Variance brings several advantage such as better type inference but also increase the range of type contructors that can be substituted securely without relying on explicit upcast</li><li>Eventually, there is ways to deal with compiler constraint on “contravariant position” error when the type is covariant or “covariant position” error when the type is contravariant.</li></ul><p>{“mode”:”full”,”isActive”:false}</p></section><footer class="page__meta"><p class="page__taxonomy"> <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong> <span itemprop="keywords"> <a href="/tags/#inference" class="page__taxonomy-item" rel="tag">inference</a><span class="sep">, </span> <a href="/tags/#scala" class="page__taxonomy-item" rel="tag">scala</a><span class="sep">, </span> <a href="/tags/#subtyping" class="page__taxonomy-item" rel="tag">subtyping</a><span class="sep">, </span> <a href="/tags/#type" class="page__taxonomy-item" rel="tag">type</a><span class="sep">, </span> <a href="/tags/#type-inference" class="page__taxonomy-item" rel="tag">type inference</a><span class="sep">, </span> <a href="/tags/#variance" class="page__taxonomy-item" rel="tag">variance</a><span class="sep">, </span> <a href="/tags/#zio" class="page__taxonomy-item" rel="tag">ZIO</a> </span></p><p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-07-21T00:00:00+03:00">July 21, 2021</time></p></footer><section class="page__share"> <a href="https://twitter.com/intent/tweet?text=Variance+Distilled%20htps%3A%2F%2Fsamuelsayag.github.io%2Fscala%2Fvariance%2Fvariance-distilled" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a> <a href="https://www.facebook.com/sharer/sharer.php?u=htps%3A%2F%2Fsamuelsayag.github.io%2Fscala%2Fvariance%2Fvariance-distilled" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=htps%3A%2F%2Fsamuelsayag.github.io%2Fscala%2Fvariance%2Fvariance-distilled" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a></section><nav class="pagination"> <a href="/bash/notes/2" class="pagination--pager" title="Bash Notes - Part 2 ">Previous</a> <a href="#" class="pagination--pager disabled">Next</a></nav></div></article><div class="page__related"><h4 class="page__related-title">You May Also Enjoy</h4><div class="grid__wrapper"><div class="grid__item"><article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork"><div class="archive__item-teaser"> <img src="/assets/images/romanesco-5020778_640.jpg" alt=""></div><h2 class="archive__item-title no_toc" itemprop="headline"> <a href="/bash/notes/2" rel="permalink">Bash Notes - Part 2 </a></h2><p class="page__meta"> <span class="page__meta-date"> <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> <time datetime="2021-02-02T00:00:00+02:00">February 2, 2021</time> </span> <span class="page__meta-sep"></span> <span class="page__meta-readtime"> <i class="far fa-fw fa-clock" aria-hidden="true"></i> 3 minute read </span></p><p class="archive__item-excerpt" itemprop="description">Bash course notes (Part 2)</p></article></div><div class="grid__item"><article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork"><div class="archive__item-teaser"> <img src="/assets/images/romanesco-5020778_640.jpg" alt=""></div><h2 class="archive__item-title no_toc" itemprop="headline"> <a href="/bash/notes/1" rel="permalink">Bash Notes - Part 1 </a></h2><p class="page__meta"> <span class="page__meta-date"> <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> <time datetime="2021-01-28T00:00:00+02:00">January 28, 2021</time> </span> <span class="page__meta-sep"></span> <span class="page__meta-readtime"> <i class="far fa-fw fa-clock" aria-hidden="true"></i> 6 minute read </span></p><p class="archive__item-excerpt" itemprop="description">Bash course notes (Part 1)</p></article></div></div></div></div></div><div id="footer" class="page__footer"><footer> <!-- start custom footer snippets --> <!-- end custom footer snippets --><div class="page__footer-follow"><ul class="social-icons"><li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li></ul></div><div class="page__footer-copyright">&copy; 2021 Samuel SAYAG. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div></footer></div><script src="/assets/js/main.min.js"></script></body></html>
